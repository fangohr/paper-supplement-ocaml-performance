# Loop optimisations in array sum

In this example two large unidimensional arrays, a and b, are filled with
floating point numbers, then a and b are summed into a third array, c, and
finally the square root of the average of the squares of the entries of c
is computed.

This directory contains 2 programs that do this in Ocaml and C++:

1. `array_test.ml`: OCaml code

2. `carray_test.cc`: C++ code

The two programs are compiled with OCaml 4.01.0 and gcc 5.2.1.
The output of running make (on an Intel Core i5-6600 processor running at
3.3 GHz) is the following:

ocamlfind ocamlopt -package unix -S -linkpkg array_test.ml -o array_test

    g++ -std=c++11 -Wall -O3 carray_test.cc -o carray_test
    time ./array_test
    Diff is 1.14688
    Fill time 2.96966 s
     Sum time 0.174502 s
    Diff time 0.0617249 s
    3.28user 0.12system 0:03.42elapsed 99%CPU (0avgtext+0avgdata 1194340maxresident)k
    0inputs+0outputs (0major+6211minor)pagefaults 0swaps
    time ./carray_test
    Diff is 1.14688
    Fill time 2.18151s
     Sum time 0.140655s
    Diff time 0.0615144s
    2.26user 0.12system 0:02.38elapsed 99%CPU (0avgtext+0avgdata 1175016maxresident)k
    0inputs+0outputs (0major+2343minor)pagefaults 0swaps

The Makefile does also create the two files array_test.s and carray_test.s
containing the assembly code produced by the two compilers.

The comparison shows that C++ is only moderately faster than OCaml. Let us,
however, have a look at the assembly code generated by the two compilers:

Here is the body of the loop which carries out the vector sum as generated by
gcc:

        .p2align 4,,10                     // Align loop start address
        .p2align 3
    .L14:
        movupd  (%rdi,%rax), %xmm0         // Get two doubles from left array to xmm0
        addq    $1, %rdx                   // Advance loop counter
        addpd   (%r8,%rax), %xmm0          // Add two doubles from right array to xmm0
        movups  %xmm0, (%rcx,%rax)         // Store two doubles to the result
        addq    $16, %rax                  // Advance offset
        cmpq    %rsi, %rdx                 // Loop check
        jb      .L14

And here is the output of the same loop as compiled by OCaml:

    .L115:
        movq    -8(%rdi), %rcx
        shrq    $9, %rcx
        cmpq    %rdx, %rcx                 // Bounds check for left array
        jbe     .L117                      // Branch in case of exception
        movsd   -4(%rdi, %rdx, 4), %xmm0   // Get item from array
        movq    -8(%rbx), %rcx
        shrq    $9, %rcx
        cmpq    %rdx, %rcx                 // Bounds check for right array
        jbe     .L117                      // Branch in case of exception
        movsd   -4(%rbx, %rdx, 4), %xmm1   // Get item from array
        addsd   %xmm0, %xmm1               // Sum the two items
        movq    -8(%rax), %rcx
        shrq    $9, %rcx
        cmpq    %rdx, %rcx                 // Bounds check for destination array
        jbe     .L117                      // Branch in case of exception
        movsd    %xmm1, -4(%rax, %rdx, 4)  // Store the sum into the destination
        movq    %rdx, %rcx
        addq    $2, %rdx
        cmpq    %rsi, %rcx                 // Loop check
        jne     .L115

It can be seen that the C++ code is compact and uses SIMD instructions to pack
two values in the xmm0 register. Interestingly, the loop counter addition is
moved far from the point of usage (the cmp instruction) probably as an effect
of instruction scheduling.

In contrast, the OCaml code is pretty large.  Every time an array is accessed,
the index is checked against the array length, despite the check is guaranteed
to always succeed (as the iteration goes from 0 to the array length minus
one). No bounds check elimination is performed and additions are done one at a
time.

Despite the difference in code quality, the impact on performance is
surprisingly small. The OCaml code takes 1.25 times what it takes for the C++
code to execute the addition of the two vectors. We believe this outcome is
mainly due to the nature of the particular computation which is very memory
intensive (tight loop with two loads, one addition, one store).

A less memory intensive version of this code is provided in the directory
summation.
